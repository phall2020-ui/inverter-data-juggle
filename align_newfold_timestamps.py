import sqlite3
import json
from datetime import datetime, timedelta
import pandas as pd
from plant_store import PlantStore, DEFAULT_DB

OUT_SQL = 'timestamp_fix_newfold.sql'

store = PlantStore(DEFAULT_DB)
# find Newfold
plants = store.list_all()
newfold = next((p for p in plants if 'newfold' in p['alias'].lower()), None)
if not newfold:
    print('Newfold Farm not found in registry. Aborting.')
    raise SystemExit(1)
plant_uid = newfold['plant_uid']
print(f"Found plant: {newfold['alias']} ({plant_uid})")

conn = sqlite3.connect(DEFAULT_DB)
cur = conn.cursor()

# Get distinct inverter timestamps and POA timestamps
cur.execute("SELECT DISTINCT ts FROM readings WHERE plant_uid=? AND emig_id LIKE 'INVERT:%'", (plant_uid,))
inv_rows = [r[0] for r in cur.fetchall()]
cur.execute("SELECT DISTINCT ts FROM readings WHERE plant_uid=? AND emig_id LIKE 'POA:%'", (plant_uid,))
poa_rows = [r[0] for r in cur.fetchall()]

if not inv_rows:
    print('No inverter readings found for plant. Nothing to align.')
    raise SystemExit(0)
if not poa_rows:
    print('No POA readings found for plant. Nothing to align.')
    raise SystemExit(0)

# Parse timestamps to pandas datetimes
inv_ts = pd.to_datetime(pd.Series(inv_rows), errors='coerce')
poa_ts = pd.to_datetime(pd.Series(poa_rows), errors='coerce')

# Round to 30-min resolution for matching
inv_round = inv_ts.dt.floor('30min')
poa_round = poa_ts.dt.floor('30min')

# Try candidate offsets (minutes)
offsets = [-60, -30, 0, 30, 60]
best = None
best_count = -1
results = []
for off in offsets:
    shifted = (inv_round + pd.to_timedelta(off, unit='m')).dt.round('30min')
    # set of strings for comparison
    s_shifted = set(shifted.dt.strftime('%Y-%m-%dT%H:%M:%S').dropna().tolist())
    s_poa = set(poa_round.dt.strftime('%Y-%m-%dT%H:%M:%S').dropna().tolist())
    common = s_shifted.intersection(s_poa)
    count = len(common)
    results.append((off, count))
    if count > best_count:
        best_count = count
        best = off

print('\nOffset candidates (minutes) and matching timestamp counts:')
for off, cnt in results:
    print(f'  {off:+4d} min -> {cnt} matches')

print(f"\nSuggested best offset: {best:+d} minutes (max matches={best_count})")

# If best is 0 or no matches, still provide SQL but mark accordingly
if best_count == 0:
    print('Warning: No overlapping timestamps found for any candidate offsets.')

# Generate SQL script to backup and shift inverter readings by best offset
print(f"\nGenerating SQL script: {OUT_SQL}")

# Collect all inverter readings for plant
cur.execute("SELECT emig_id, ts, payload FROM readings WHERE plant_uid=? AND emig_id LIKE 'INVERT:%' ORDER BY emig_id, ts", (plant_uid,))
rows = cur.fetchall()

if not rows:
    print('No inverter rows to process. Exiting.')
    raise SystemExit(0)

# Build SQL
with open(OUT_SQL, 'w', encoding='utf-8') as f:
    f.write('-- SQL script to shift inverter timestamps for Newfold Farm\n')
    f.write('-- Generated by align_newfold_timestamps.py\n')
    f.write('BEGIN TRANSACTION;\n')
    f.write('-- Backup affected rows\n')
    f.write("CREATE TABLE IF NOT EXISTS readings_backup_newfold AS SELECT * FROM readings WHERE plant_uid='" + plant_uid + "';\n")
    f.write('-- Delete original inverter rows (will re-insert shifted rows)\n')
    f.write("DELETE FROM readings WHERE plant_uid='" + plant_uid + "' AND emig_id LIKE 'INVERT:%';\n")

    # Insert shifted rows
    f.write('-- Insert shifted inverter readings\n')
    for emig_id, ts_str, payload_json in rows:
        # parse ts
        try:
            ts_dt = pd.to_datetime(ts_str)
        except Exception:
            continue
        # apply offset
        new_dt = ts_dt + pd.Timedelta(minutes=best)
        new_ts = new_dt.strftime('%Y-%m-%dT%H:%M:%S')
        # Escape single quotes in payload
        payload_escaped = payload_json.replace("'", "''")
        # Write INSERT OR REPLACE
        sql = ("INSERT OR REPLACE INTO readings (plant_uid, emig_id, ts, payload) VALUES ('%s', '%s', '%s', '%s');\n"
               % (plant_uid, emig_id, new_ts, payload_escaped))
        f.write(sql)

    f.write('COMMIT;\n')

print(f"SQL script written to {OUT_SQL}. REVIEW before executing.\n")
print('To apply the change: run the SQL against the database, e.g.:')
print(f"  sqlite3 {DEFAULT_DB} < {OUT_SQL}\n")

conn.close()
print('Done.')
